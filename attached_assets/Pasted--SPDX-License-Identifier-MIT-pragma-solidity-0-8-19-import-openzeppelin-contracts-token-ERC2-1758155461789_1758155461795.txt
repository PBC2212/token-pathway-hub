// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title AssetBackedToken
 * @dev ERC20 token for each asset category, mint/burn controlled by parent contract (holds MINTER_ROLE)
 */
contract AssetBackedToken is ERC20, AccessControl, Pausable {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    string public assetCategory;

    constructor(
        string memory name,
        string memory symbol,
        string memory _assetCategory,
        address minter
    ) ERC20(name, symbol) {
        require(minter != address(0), "Invalid minter address");
        _grantRole(DEFAULT_ADMIN_ROLE, minter);
        _grantRole(MINTER_ROLE, minter);
        assetCategory = _assetCategory;
    }

    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) whenNotPaused {
        require(to != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be positive");
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external onlyRole(MINTER_ROLE) whenNotPaused {
        require(from != address(0), "Invalid burn address");
        require(amount > 0, "Amount must be positive");
        _burn(from, amount);
    }
}

/**
 * @title MultiTokenRwaBackedStablecoin
 * @dev Asset-backed stablecoin system with scalable categories and tokens
 */
contract MultiTokenRwaBackedStablecoin is AccessControl, Pausable, ReentrancyGuard {
    // Role definitions
    bytes32 public constant VERIFIER_ROLE = keccak256("VERIFIER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");
    bytes32 public constant LIQUIDATOR_ROLE = keccak256("LIQUIDATOR_ROLE");

    // Asset Categories
    enum RwaCategory { RealEstate, Commodities, Bonds, Equipment, Inventory, Other }

    // Pledge lifecycle
    enum PledgeStatus { Pending, Verified, Minted, Rejected, Cancelled, Redeemed, Liquidated }

    // Pledge record
    struct Pledge {
        string rwaIdentifier;
        address pledger;
        PledgeStatus status;
        uint256 rwaValueUSD;
        uint256 stablecoinAmount;
        uint256 timestamp;
        uint256 lastValuationTime;
        string metadata;
        address verifiedBy;
        RwaCategory category;
        uint256 ltv;
        bool isRedeemable;
    }

    struct RedemptionRequest {
        uint256 pledgeId;
        uint256 stablecoinAmount;
        uint256 requestTime;
        bool processed;
        address requester;
        RwaCategory category;
    }

    struct TokenInfo {
        AssetBackedToken token;
        string name;
        string symbol;
        uint256 totalMinted;
        uint256 totalReserves;
        bool active;
    }

    // Configurable parameters
    uint256 public constant BASIS_POINTS = 10000;
    uint256 public constant MIN_RWA_VALUE = 1_000e18;        // $1,000 min
    uint256 public constant MAX_RWA_VALUE = 100_000_000e18;  // $100M max
    uint256 public pledgeExpiryTime = 30 days;
    uint256 public maxRwaIdentifierLength = 256;
    uint256 public revaluationInterval = 90 days;
    uint256 public redemptionDelay = 7 days;
    uint256 public collateralizationRatio = 12000;            // 120% min collateralization (basis points)

    address public treasury;
    uint256 public reserveRatio = 500;                       // 5% reserves (basis points)
    uint256 public totalRwaValue;

    // State tracking
    mapping(uint256 => Pledge) public pledges;
    mapping(address => uint256[]) public userPledges;
    mapping(string => bool) public rwaExists;
    mapping(string => uint256) public rwaToPledgeId;
    mapping(uint256 => RedemptionRequest) public redemptionRequests;
    mapping(RwaCategory => uint256) public categoryLimits;
    mapping(RwaCategory => uint256) public categoryValues;
    mapping(RwaCategory => TokenInfo) public categoryTokens;

    uint256 public nextPledgeId;
    uint256 public nextRedemptionId;
    uint256 public totalPledges;
    uint256 public totalVerifiedPledges;
    uint256 public totalMintedPledges;

    // Events
    event PledgeSubmitted(uint256 indexed pledgeId, address indexed pledger, string rwaIdentifier, uint256 rwaValueUSD, RwaCategory category);
    event PledgeVerified(uint256 indexed pledgeId, address indexed verifier, uint256 rwaValueUSD);
    event PledgeRejected(uint256 indexed pledgeId, address indexed verifier, string reason);
    event PledgeCancelled(uint256 indexed pledgeId, address indexed pledger);
    event StablecoinMinted(address indexed user, uint256 indexed pledgeId, uint256 amount, RwaCategory category, address tokenAddress);
    event RedemptionRequested(uint256 indexed redemptionId, uint256 indexed pledgeId, address indexed requester, uint256 amount, RwaCategory category);
    event RedemptionProcessed(uint256 indexed redemptionId, uint256 indexed pledgeId, uint256 amount);
    event RwaRevalued(uint256 indexed pledgeId, uint256 oldValue, uint256 newValue, address indexed oracle);
    event CollateralizationUpdated(uint256 oldRatio, uint256 newRatio);
    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);
    event CategoryLimitUpdated(RwaCategory indexed category, uint256 oldLimit, uint256 newLimit);
    event LiquidationExecuted(uint256 indexed pledgeId, address indexed liquidator, uint256 rwaValue);
    event TokenDeployed(RwaCategory indexed category, address indexed tokenAddress, string symbol);
    event CategoryActivationChanged(RwaCategory indexed category, bool active);
    event RescueERC20(address indexed token, address indexed to, uint256 amount);
    event RescueETH(address indexed to, uint256 amount);

    // Custom errors
    error PledgeNotFound();
    error PledgeAlreadyProcessed();
    error NotPledgeOwner();
    error PledgeNotVerified();
    error PledgeExpired();
    error RwaAlreadyPledged();
    error InvalidRwaValue();
    error InvalidRwaIdentifier();
    error InvalidPledgeStatus();
    error ZeroAddress();
    error InvalidCollateralizationRatio();
    error CategoryLimitExceeded();
    error RevaluationRequired();
    error InsufficientCollateralization();
    error RedemptionDelayNotMet();
    error RedemptionAlreadyProcessed();
    error NotRedeemable();
    error InvalidRedemptionAmount();
    error ReservesInsufficient();
    error TokenNotDeployed();
    error CategoryNotActive();

    modifier validAddress(address addr) {
        require(addr != address(0), "Address is zero");
        _;
    }

    modifier pledgeExists(uint256 pledgeId) {
        if (pledges[pledgeId].pledger == address(0)) revert PledgeNotFound();
        _;
    }

    modifier categoryActive(RwaCategory category) {
        require(categoryTokens[category].active, "Category not active");
        _;
    }

    constructor(address _treasury) validAddress(_treasury) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(VERIFIER_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(ORACLE_ROLE, msg.sender);
        _grantRole(LIQUIDATOR_ROLE, msg.sender);

        treasury = _treasury;
        nextPledgeId = 1;
        nextRedemptionId = 1;

        categoryLimits[RwaCategory.RealEstate] = 50_000_000e18;
        categoryLimits[RwaCategory.Commodities] = 20_000_000e18;
        categoryLimits[RwaCategory.Bonds] = 30_000_000e18;
        categoryLimits[RwaCategory.Equipment] = 10_000_000e18;
        categoryLimits[RwaCategory.Inventory] = 15_000_000e18;
        categoryLimits[RwaCategory.Other] = 5_000_000e18;

        _deployAllTokens();
    }

    function _deployAllTokens() internal {
        _deployTokenForCategory(RwaCategory.RealEstate, "Real Estate USD", "RUSD");
        _deployTokenForCategory(RwaCategory.Commodities, "Commodities USD", "CUSD");
        _deployTokenForCategory(RwaCategory.Bonds, "Bonds USD", "BUSD");
        _deployTokenForCategory(RwaCategory.Equipment, "Equipment USD", "EUSD");
        _deployTokenForCategory(RwaCategory.Inventory, "Inventory USD", "IUSD");
        _deployTokenForCategory(RwaCategory.Other, "Other Assets USD", "OUSD");
    }

    function _deployTokenForCategory(RwaCategory category, string memory name, string memory symbol) internal {
        AssetBackedToken token = new AssetBackedToken(name, symbol, _getCategoryName(category), address(this));
        categoryTokens[category] = TokenInfo({
            token: token,
            name: name,
            symbol: symbol,
            totalMinted: 0,
            totalReserves: 0,
            active: true
        });
        emit TokenDeployed(category, address(token), symbol);
    }

    function _getCategoryName(RwaCategory category) internal pure returns (string memory) {
        if (category == RwaCategory.RealEstate) return "Real Estate";
        if (category == RwaCategory.Commodities) return "Commodities";
        if (category == RwaCategory.Bonds) return "Bonds";
        if (category == RwaCategory.Equipment) return "Equipment";
        if (category == RwaCategory.Inventory) return "Inventory";
        if (category == RwaCategory.Other) return "Other";
        return "Unknown";
    }

    function submitPledge(
        string calldata rwaIdentifier,
        uint256 estimatedValueUSD,
        RwaCategory category,
        string calldata metadata,
        bool isRedeemable
    ) external whenNotPaused nonReentrant categoryActive(category) returns (uint256) {
        require(bytes(rwaIdentifier).length > 0 && bytes(rwaIdentifier).length <= maxRwaIdentifierLength, "Invalid RWA identifier");
        require(estimatedValueUSD >= MIN_RWA_VALUE && estimatedValueUSD <= MAX_RWA_VALUE, "Invalid RWA value");
        require(!rwaExists[rwaIdentifier], "RWA already pledged");
        require(bytes(metadata).length <= 1024, "Metadata too long");

        uint256 pledgeId = nextPledgeId++;

        pledges[pledgeId] = Pledge({
            rwaIdentifier: rwaIdentifier,
            pledger: msg.sender,
            status: PledgeStatus.Pending,
            rwaValueUSD: estimatedValueUSD,
            stablecoinAmount: 0,
            timestamp: block.timestamp,
            lastValuationTime: 0,
            metadata: metadata,
            verifiedBy: address(0),
            category: category,
            ltv: 8000,
            isRedeemable: isRedeemable
        });
        userPledges[msg.sender].push(pledgeId);
        rwaExists[rwaIdentifier] = true;
        rwaToPledgeId[rwaIdentifier] = pledgeId;
        totalPledges++;
        emit PledgeSubmitted(pledgeId, msg.sender, rwaIdentifier, estimatedValueUSD, category);
        return pledgeId;
    }

    function verifyPledge(
        uint256 pledgeId,
        uint256 officialValueUSD,
        uint256 ltvBasisPoints
    ) external onlyRole(VERIFIER_ROLE) pledgeExists(pledgeId) {
        Pledge storage pledge = pledges[pledgeId];
        require(pledge.status == PledgeStatus.Pending, "Already processed");
        require(block.timestamp <= pledge.timestamp + pledgeExpiryTime, "Pledge expired");
        require(officialValueUSD >= MIN_RWA_VALUE && officialValueUSD <= MAX_RWA_VALUE, "Invalid RWA value");
        require(categoryTokens[pledge.category].active, "Category not active");

        uint256 newCategoryValue = categoryValues[pledge.category] + officialValueUSD;
        require(newCategoryValue <= categoryLimits[pledge.category], "Category limit exceeded");
        require(ltvBasisPoints >= 1000 && ltvBasisPoints <= BASIS_POINTS, "LTV must be 10% to 100%");

        uint256 maxStablecoinAmount = (officialValueUSD * ltvBasisPoints) / BASIS_POINTS;

        pledge.status = PledgeStatus.Verified;
        pledge.rwaValueUSD = officialValueUSD;
        pledge.stablecoinAmount = maxStablecoinAmount;
        pledge.verifiedBy = msg.sender;
        pledge.lastValuationTime = block.timestamp;
        pledge.ltv = ltvBasisPoints;

        categoryValues[pledge.category] = newCategoryValue;
        totalVerifiedPledges++;
        totalRwaValue += officialValueUSD;
        emit PledgeVerified(pledgeId, msg.sender, officialValueUSD);
    }

    function mintStablecoins(uint256 pledgeId) external whenNotPaused nonReentrant pledgeExists(pledgeId) {
        Pledge storage pledge = pledges[pledgeId];
        require(msg.sender == pledge.pledger, "Not pledge owner");
        require(pledge.status == PledgeStatus.Verified, "Not verified");
        require(block.timestamp <= pledge.timestamp + pledgeExpiryTime, "Pledge expired");
        require(categoryTokens[pledge.category].active, "Category not active");

        uint256 amount = pledge.stablecoinAmount;
        require(amount > 0, "No stablecoins available");

        TokenInfo storage tokenInfo = categoryTokens[pledge.category];

        uint256 reserveAmount = (amount * reserveRatio) / BASIS_POINTS;

        uint256 projectedTotalMinted = tokenInfo.totalMinted + amount + reserveAmount;
        uint256 projectedTotalReserves = tokenInfo.totalReserves + reserveAmount;

        uint256 categoryValue = categoryValues[pledge.category] + projectedTotalReserves;
        if (projectedTotalMinted > 0) {
            uint256 projectedCollateralization = (categoryValue * BASIS_POINTS) / projectedTotalMinted;
            require(projectedCollateralization >= collateralizationRatio, "Insufficient collateralization");
        }
        pledge.status = PledgeStatus.Minted;
        pledge.stablecoinAmount = 0;
        totalMintedPledges++;

        if (reserveAmount > 0) {
            tokenInfo.token.mint(treasury, reserveAmount);
            tokenInfo.totalReserves += reserveAmount;
        }
        tokenInfo.token.mint(msg.sender, amount);
        tokenInfo.totalMinted += amount + reserveAmount;
        emit StablecoinMinted(msg.sender, pledgeId, amount, pledge.category, address(tokenInfo.token));
    }

    function requestRedemption(uint256 pledgeId, uint256 stablecoinAmount) external nonReentrant pledgeExists(pledgeId) returns (uint256) {
        Pledge storage pledge = pledges[pledgeId];
        require(pledge.status == PledgeStatus.Minted, "Not minted");
        require(pledge.isRedeemable, "Not redeemable");
        require(categoryTokens[pledge.category].active, "Category not active");
        TokenInfo storage tokenInfo = categoryTokens[pledge.category];
        AssetBackedToken token = tokenInfo.token;
        require(token.balanceOf(msg.sender) >= stablecoinAmount, "Insufficient token balance");
        require(stablecoinAmount > 0, "Redemption amount zero");
        require(block.timestamp <= pledge.lastValuationTime + revaluationInterval, "Requires revaluation");

        uint256 redemptionId = nextRedemptionId++;
        redemptionRequests[redemptionId] = RedemptionRequest({
            pledgeId: pledgeId,
            stablecoinAmount: stablecoinAmount,
            requestTime: block.timestamp,
            processed: false,
            requester: msg.sender,
            category: pledge.category
        });

        token.burn(msg.sender, stablecoinAmount);
        require(tokenInfo.totalMinted >= stablecoinAmount, "Inconsistent minted total");
        tokenInfo.totalMinted -= stablecoinAmount;
        emit RedemptionRequested(redemptionId, pledgeId, msg.sender, stablecoinAmount, pledge.category);
        return redemptionId;
    }

    function processRedemption(uint256 redemptionId) external onlyRole(DEFAULT_ADMIN_ROLE) {
        RedemptionRequest storage request = redemptionRequests[redemptionId];
        require(!request.processed, "Already processed");
        require(block.timestamp >= request.requestTime + redemptionDelay, "Delay not met");

        Pledge storage pledge = pledges[request.pledgeId];
        uint256 maxAllowed = (pledge.rwaValueUSD * pledge.ltv) / BASIS_POINTS;
        if (request.stablecoinAmount >= maxAllowed) {
            pledge.status = PledgeStatus.Redeemed;
            if (categoryValues[pledge.category] >= pledge.rwaValueUSD) {
                categoryValues[pledge.category] -= pledge.rwaValueUSD;
            } else {
                categoryValues[pledge.category] = 0;
            }
            if (totalRwaValue >= pledge.rwaValueUSD) {
                totalRwaValue -= pledge.rwaValueUSD;
            } else {
                totalRwaValue = 0;
            }
            rwaExists[pledge.rwaIdentifier] = false;
            delete rwaToPledgeId[pledge.rwaIdentifier];
        }
        request.processed = true;
        emit RedemptionProcessed(redemptionId, request.pledgeId, request.stablecoinAmount);
    }

    function revalueRwa(uint256 pledgeId, uint256 newValueUSD) external onlyRole(ORACLE_ROLE) pledgeExists(pledgeId) {
        Pledge storage pledge = pledges[pledgeId];
        require(pledge.status == PledgeStatus.Minted, "Invalid status");
        require(newValueUSD >= MIN_RWA_VALUE, "Value too low");
        uint256 oldValue = pledge.rwaValueUSD;
        pledge.rwaValueUSD = newValueUSD;
        pledge.lastValuationTime = block.timestamp;

        if (categoryValues[pledge.category] >= oldValue) {
            categoryValues[pledge.category] = categoryValues[pledge.category] - oldValue + newValueUSD;
        } else {
            categoryValues[pledge.category] = newValueUSD;
        }
        if (totalRwaValue >= oldValue) {
            totalRwaValue = totalRwaValue - oldValue + newValueUSD;
        } else {
            totalRwaValue = newValueUSD;
        }
        emit RwaRevalued(pledgeId, oldValue, newValueUSD, msg.sender);

        uint256 currentValue = (newValueUSD * pledge.ltv) / BASIS_POINTS;
        uint256 categorySupply = categoryTokens[pledge.category].totalMinted;
        if (categorySupply > 0) {
            uint256 catValuePlusReserves = categoryValues[pledge.category] + categoryTokens[pledge.category].totalReserves;
            uint256 currentCollateral = (catValuePlusReserves * BASIS_POINTS) / categorySupply;
            if (currentCollateral < collateralizationRatio) {
                emit LiquidationExecuted(pledgeId, msg.sender, newValueUSD);
            }
        }
    }

    function liquidatePledge(uint256 pledgeId) external onlyRole(LIQUIDATOR_ROLE) pledgeExists(pledgeId) {
        Pledge storage pledge = pledges[pledgeId];
        require(pledge.status == PledgeStatus.Minted, "Not minted");
        pledge.status = PledgeStatus.Liquidated;
        if (categoryValues[pledge.category] >= pledge.rwaValueUSD) {
            categoryValues[pledge.category] -= pledge.rwaValueUSD;
        } else {
            categoryValues[pledge.category] = 0;
        }
        if (totalRwaValue >= pledge.rwaValueUSD) {
            totalRwaValue -= pledge.rwaValueUSD;
        } else {
            totalRwaValue = 0;
        }
        rwaExists[pledge.rwaIdentifier] = false;
        delete rwaToPledgeId[pledge.rwaIdentifier];
        emit LiquidationExecuted(pledgeId, msg.sender, pledge.rwaValueUSD);
    }

    // View & admin functions omitted for brevity. Please refer to your original contract for full details.
    // These include getters for pledge/token/category info, pledge/user statistics,
    // as well as admin-only configuration functions for collateralization, treasury, limits, and rescue logic.

    // Emergency Pause
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    // Rescue tokens/ETH
    function rescueERC20(address tokenAddr, address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) validAddress(to) {
        require(tokenAddr != address(0), "Token address is zero");
        IERC20(tokenAddr).transfer(to, amount);
        emit RescueERC20(tokenAddr, to, amount);
    }

    function rescueETH(address payable to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) validAddress(to) {
        (bool sent, ) = to.call{value: amount}("");
        require(sent, "ETH transfer failed");
        emit RescueETH(to, amount);
    }

    receive() external payable {}
}
